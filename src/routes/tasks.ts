import { Hono } from "hono";
import type { AppEnv } from "../index"; // Use import type for types
import { zValidator } from "@hono/zod-validator";
import { z } from "zod";
import type { Task, TaskInsert, TaskUpdate } from "../types"; // Import task types
import { getSupabaseClient } from "../db/client"; // Import Supabase client helper
import {
	HttpError,
	NotFoundError,
	DatabaseError,
	BadRequestError,
	InternalServerError,
} from "../errors/httpErrors";
import type { PostgrestError } from "@supabase/supabase-js";

const taskSchema = z.object({
	id: z.string().uuid().optional(), // UUID generated by DB or provided for update
	title: z.string().min(1),
	description: z.string().optional().nullable(), // Allow null in Zod schema
	status: z.enum(["todo", "inprogress", "done"]).default("todo"),
	priority: z.enum(["low", "medium", "high"]).default("medium"),
	due_date: z.string().datetime({ offset: true }).optional().nullable(), // Allow null, specify offset for TZ
	user_id: z.string().uuid(), // Changed from userId
	created_at: z.string().datetime({ offset: true }).optional(),
	updated_at: z.string().datetime({ offset: true }).optional(),
});

const tasks = new Hono<AppEnv>();

// --- Helper function to handle Supabase errors ---
function handleSupabaseError(error: PostgrestError, context: string): never {
	console.error(`[Supabase Error - ${context}]`, error);
	if (error.code === "PGRST116") {
		throw new NotFoundError(
			`${context} failed: Resource not found or insufficient permissions.`,
		);
	}
	// For other database errors, throw a generic DatabaseError
	throw new DatabaseError(`${context} failed`, error);
}

// GET /api/tasks - タスク一覧取得
tasks.get("/", async (c) => {
	const userId = c.get("userId");
	const supabase = getSupabaseClient(c);

	try {
		const { data, error } = await supabase
			.from("tasks")
			.select("*")
			.eq("user_id", userId) // Filter by authenticated user
			.order("created_at", { ascending: false }); // Example ordering

		if (error) {
			handleSupabaseError(error, "Fetching tasks");
		}

		return c.json<{ tasks: Task[] }>({ tasks: data || [] });
	} catch (err) {
		if (err instanceof HttpError) {
			throw err; // Re-throw known HttpError
		}
		console.error("[GET /tasks] Unexpected error:", err);
		throw new InternalServerError(
			"An unexpected error occurred while fetching tasks.",
		);
	}
});

// POST /api/tasks - タスク作成
const taskInsertSchema = taskSchema.omit({
	id: true,
	user_id: true, // user_id will be added from context
	created_at: true,
	updated_at: true,
});
tasks.post("/", zValidator("json", taskInsertSchema), async (c) => {
	const validatedData = c.req.valid("json");
	const userId = c.get("userId");
	if (!userId) return c.json({ error: "Unauthorized" }, 401); // Should be caught by middleware, but double-check

	const supabase = getSupabaseClient(c);

	try {
		const taskToInsert = {
			...validatedData,
			user_id: userId, // Add the user_id from the authenticated user
		};

		const { data, error } = await supabase
			.from("tasks")
			.insert(taskToInsert)
			.select() // Return the created record
			.single(); // Expecting a single record back

		if (error) {
			handleSupabaseError(error, "Creating task");
		}
		if (!data) {
			console.error("Task creation returned no data");
			throw new InternalServerError("Failed to create task - no data returned");
		}

		return c.json<Task>(data, 201);
	} catch (err) {
		if (err instanceof HttpError) {
			throw err; // Re-throw known HttpError
		}
		console.error("[POST /tasks] Unexpected error:", err);
		throw new InternalServerError(
			"An unexpected error occurred while creating the task.",
		);
	}
});

// GET /api/tasks/:id - 特定タスク取得
tasks.get("/:id", async (c) => {
	const { id } = c.req.param();
	if (
		!id ||
		typeof id !== "string" ||
		!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(
			id,
		)
	) {
		throw new BadRequestError("Invalid Task ID format");
	}
	const userId = c.get("userId");
	const supabase = getSupabaseClient(c);

	try {
		const { data, error } = await supabase
			.from("tasks")
			.select("*")
			.eq("id", id)
			.eq("user_id", userId) // Ensure the user owns the task
			.maybeSingle(); // Use maybeSingle to differentiate null data from errors

		if (error) {
			// maybeSingle() returns error only for real issues, not for not found
			handleSupabaseError(error, "Fetching task by ID");
		}

		if (!data) {
			// data is null if not found by RLS or ID
			throw new NotFoundError(`Task with id ${id} not found`);
		}

		return c.json<Task>(data);
	} catch (err) {
		if (err instanceof HttpError) {
			throw err; // Re-throw known HttpError
		}
		console.error(`[GET /tasks/:id] Unexpected error for id ${id}:`, err);
		throw new InternalServerError(
			"An unexpected error occurred while fetching the task.",
		);
	}
});

// PUT /api/tasks/:id - タスク更新
const taskUpdateSchema = taskSchema
	.partial()
	.omit({ id: true, user_id: true, created_at: true }); // Keep updated_at implicitly updated
tasks.put("/:id", zValidator("json", taskUpdateSchema), async (c) => {
	const { id } = c.req.param();
	if (
		!id ||
		typeof id !== "string" ||
		!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(
			id,
		)
	) {
		throw new BadRequestError("Invalid Task ID format");
	}
	const validatedData: Partial<TaskUpdate> = c.req.valid("json");
	const userId = c.get("userId");
	const supabase = getSupabaseClient(c);

	try {
		const taskToUpdate = {
			...validatedData,
			updated_at: new Date().toISOString(), // Explicitly set updated_at
		};

		const { data, error } = await supabase
			.from("tasks")
			.update(taskToUpdate)
			.eq("id", id)
			.eq("user_id", userId) // Ensure user owns the task
			.select()
			.maybeSingle(); // Use maybeSingle for update as well

		if (error) {
			handleSupabaseError(error, "Updating task");
		}
		if (!data) {
			// If update affects 0 rows (wrong id or RLS), maybeSingle returns null
			// Check if task exists first (optional, maybeSingle handles it)
			throw new NotFoundError(
				`Task with id ${id} not found or update forbidden`,
			);
		}

		return c.json<Task>(data);
	} catch (err) {
		if (err instanceof HttpError) {
			throw err; // Re-throw known HttpError
		}
		console.error(`[PUT /tasks/:id] Unexpected error for id ${id}:`, err);
		throw new InternalServerError(
			"An unexpected error occurred while updating the task.",
		);
	}
});

// DELETE /api/tasks/:id - タスク削除
tasks.delete("/:id", async (c) => {
	const { id } = c.req.param();
	if (
		!id ||
		typeof id !== "string" ||
		!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(
			id,
		)
	) {
		throw new BadRequestError("Invalid Task ID format");
	}
	const userId = c.get("userId");
	const supabase = getSupabaseClient(c);

	try {
		const { error, count } = await supabase
			.from("tasks")
			.delete({ count: "exact" }) // Request count of deleted rows
			.eq("id", id)
			.eq("user_id", userId); // Ensure user owns the task

		if (error) {
			handleSupabaseError(error, "Deleting task");
		}

		if (count === 0) {
			// Task didn't exist or didn't belong to the user
			console.warn(
				`Delete failed for task ${id} by user ${userId}. Task not found or permission denied.`,
			);
			throw new NotFoundError(
				`Task with id ${id} not found or delete forbidden`,
			);
		}

		// Use 204 No Content for successful deletions as there's no body
		return c.body(null, 204);
		// return c.json({ message: 'Task deleted successfully' }, 200); // Alternative with body
	} catch (err) {
		if (err instanceof HttpError) {
			throw err; // Re-throw known HttpError
		}
		console.error(`[DELETE /tasks/:id] Unexpected error for id ${id}:`, err);
		throw new InternalServerError(
			"An unexpected error occurred while deleting the task.",
		);
	}
});

export default tasks;
