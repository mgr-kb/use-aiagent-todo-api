import { Hono } from "hono";
import type { AppEnv } from "../index"; // Use import type for types
import { zValidator } from "@hono/zod-validator";
import { z } from "zod";
import type { Task, TaskInsert, TaskUpdate } from "../types"; // Import task types
import { mockTasks } from "../mocks/tasks"; // Import mock data

const taskSchema = z.object({
	id: z.string().uuid().optional(), // UUID generated by DB or provided for update
	title: z.string().min(1),
	description: z.string().optional().nullable(), // Allow null in Zod schema
	status: z.enum(["todo", "inprogress", "done"]).default("todo"),
	priority: z.enum(["low", "medium", "high"]).default("medium"),
	due_date: z.string().datetime({ offset: true }).optional().nullable(), // Allow null, specify offset for TZ
	user_id: z.string().uuid(), // Changed from userId
	created_at: z.string().datetime({ offset: true }).optional(),
	updated_at: z.string().datetime({ offset: true }).optional(),
});

const tasks = new Hono<AppEnv>();

// GET /api/tasks - タスク一覧取得
tasks.get("/", (c) => {
	const userId = c.get("userId");
	const userTasks: Task[] = mockTasks.filter((t) => t.user_id === userId); // Use user_id from Task type
	return c.json<{ tasks: Task[] }>({ tasks: userTasks }); // Type the response
});

// POST /api/tasks - タスク作成
const taskInsertSchema = taskSchema.omit({
	id: true,
	user_id: true,
	created_at: true,
	updated_at: true,
});
tasks.post("/", zValidator("json", taskInsertSchema), async (c) => {
	const newTaskData = c.req.valid("json");
	const userId = c.get("userId");
	if (!userId) return c.json({ error: "Unauthorized" }, 401);
	const createdTask: Task = {
		...newTaskData,
		id: crypto.randomUUID(),
		user_id: userId, // Correct field name
		created_at: new Date().toISOString(),
		updated_at: new Date().toISOString(),
	};
	mockTasks.push(createdTask);
	return c.json<Task>(createdTask, 201); // Type the response
});

// GET /api/tasks/:id - 特定タスク取得
tasks.get("/:id", (c) => {
	const { id } = c.req.param();
	const userId = c.get("userId");
	const task = mockTasks.find((t) => t.id === id && t.user_id === userId); // Correct field name
	if (!task) {
		return c.notFound();
	}
	return c.json<Task>(task); // Type the response
});

// PUT /api/tasks/:id - タスク更新
const taskUpdateSchema = taskSchema
	.partial()
	.omit({ id: true, user_id: true, created_at: true }); // Keep updated_at
tasks.put("/:id", zValidator("json", taskUpdateSchema), async (c) => {
	const { id } = c.req.param();
	const updateData: Partial<TaskUpdate> = c.req.valid("json"); // Use partial update type
	const userId = c.get("userId");
	if (!userId) return c.json({ error: "Unauthorized" }, 401);
	const taskIndex = mockTasks.findIndex(
		(t) => t.id === id && t.user_id === userId,
	); // Correct field name
	if (taskIndex === -1) {
		return c.notFound();
	}
	const updatedTask: Task = {
		...mockTasks[taskIndex],
		...updateData,
		updated_at: new Date().toISOString(), // Correct field name, ensure it's always updated
	};
	mockTasks[taskIndex] = updatedTask; // Assign the fully typed object
	return c.json<Task>(mockTasks[taskIndex]); // Type the response
});

// DELETE /api/tasks/:id - タスク削除
tasks.delete("/:id", async (c) => {
	const { id } = c.req.param();
	const userId = c.get("userId");
	if (!userId) return c.json({ error: "Unauthorized" }, 401);
	const taskIndex = mockTasks.findIndex(
		(t) => t.id === id && t.user_id === userId,
	); // Correct field name
	if (taskIndex === -1) {
		return c.notFound();
	}
	mockTasks.splice(taskIndex, 1);
	return c.json({ message: "Task deleted successfully" }, 200);
});

export default tasks;
